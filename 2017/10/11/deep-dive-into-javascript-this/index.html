<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 深入 JavaScript 之 this · Kingluo's Blog</title><meta name="description" content="深入 JavaScript 之 this - Kingluo"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://kingluo.me/blog/atom.xml" title="Kingluo's Blog"><meta name="generator" content="Hexo 5.3.0"><link rel="alternate" href="/atom.xml" title="Kingluo's Blog" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/avatar.jpg" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/about/" target="_self" class="nav-list-link">ABOUT</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">深入 JavaScript 之 this</h1><div class="post-tags"><a href="/tags/%E6%8A%80%E6%9C%AF/" class="post-tag-title">#技术</a></div><div class="post-info">2017年10月11日</div><div class="post-content"><blockquote>
<p>“this关键字是JavaScript中最复杂的机制之一。它是一个很特别的关键字，被自动定义在所有函数的作用域中。但是即使是非常有经验的JavaScript开发者也很难说清它到底指向什么。”          </p>
<p>​                                      —— 《你不知道的 JavaScript （上）》</p>
</blockquote>
<a id="more"></a>

<h2 id="绑定规则"><a href="#绑定规则" class="headerlink" title="绑定规则"></a>绑定规则</h2><p><code>this</code>有如下四种绑定规则：</p>
<h3 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h3><p>定义：<strong>不带任何修饰</strong>的<strong>直接</strong>函数调用。</p>
<p>指向：在非严格模式下指向全局对象，严格模式下指向<code>undefined</code>。</p>
<p>代码实例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line">foo(); <span class="comment">//10.</span></span><br><span class="line"><span class="comment">//此处等价于window.foo()，故this指向window。</span></span><br></pre></td></tr></table></figure>
<p>特殊情况：<code>function</code>作为函数返回值进行调用，如下例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;window&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> x = &#123;</span><br><span class="line">  name: <span class="string">&#x27;x&#x27;</span>,</span><br><span class="line">  getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 此处相当于(x.getName())()，也可看作var foo = x.getName();foo()。</span></span><br><span class="line">x.getName()(); <span class="comment">// window</span></span><br></pre></td></tr></table></figure>

<h3 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h3><p>定义：函数执行的时候有上下文对象（调用者），也就是说函数是作为对象的属性进行调用。</p>
<p>指向：上下文对象（调用者）。</p>
<p>代码示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">10</span>,</span><br><span class="line">  foo: foo,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// this指向调用者obj，此处打印obj.a。</span></span><br><span class="line">obj.foo(); <span class="comment">// 10。</span></span><br></pre></td></tr></table></figure>
<p>隐式丢失：当作为对象属性的方法，被赋值给一个新的变量并调用时，会发生隐式丢失情况，此时将应用默认绑定，见下例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">10</span>,</span><br><span class="line">  foo: foo,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// this指向调用者obj，此处打印obj.a。</span></span><br><span class="line">obj.foo(); <span class="comment">// 10。</span></span><br><span class="line"><span class="keyword">var</span> bar = obj.foo;</span><br><span class="line">bar(); <span class="comment">// undefined。隐式丢失，此时应用的是默认绑定，this 指向 window 对象。</span></span><br></pre></td></tr></table></figure>
<p>隐式丢失的另一种情况是参数传递，这是一种隐式赋值（将实参赋值给形参），所以会有如下情况：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;foo&#x27;</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name); <span class="comment">// foo。此时作为参数的函数 bar 应用的是默认绑定。</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<p>PS：链式调用如<code>xx.yy.obj.foo()</code>，<code>this</code>指向直接上级。</p>
<h3 id="显式绑定"><a href="#显式绑定" class="headerlink" title="显式绑定"></a>显式绑定</h3><p>定义：通过<code>bind</code>、<code>call</code>、<code>apply</code>显式的指定<code>this</code>指向。</p>
<p>指向：显式指定的<code>this</code>对象。</p>
<p>例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span>: <span class="number">3</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a + b + <span class="built_in">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo1</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a + b + <span class="built_in">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo2</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a + b + <span class="built_in">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line">foo.call(obj, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>); <span class="comment">// ab3</span></span><br><span class="line">foo1.apply(obj, [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]); <span class="comment">// ab3</span></span><br><span class="line"></span><br><span class="line">foo2 = foo2.bind(obj);</span><br><span class="line">foo2(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>); <span class="comment">// ab3</span></span><br></pre></td></tr></table></figure>
<p>特殊情况：当指定的<code>this</code>对象为<code>null</code>或者<code>undefined</code>时，此时函数内部的<code>this</code>将应用默认绑定。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">123</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">a</span>: <span class="number">3</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a + b + <span class="built_in">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// this 指向全局对象</span></span><br><span class="line">foo.call(<span class="literal">null</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>); <span class="comment">// ab123</span></span><br></pre></td></tr></table></figure>
<p>PS：当无需指定<code>this</code>时，使用空对象<code>&#123;&#125;</code>代替<code>null</code>作为<code>call</code>/<code>bind</code>/<code>apply</code>方法的第一个参数是一个更好的选择，当然，如果使用<code>Object.create(null)</code>就更好了，因为比空对象<code>&#123;&#125;</code>要更“空”。</p>
<h3 id="new绑定"><a href="#new绑定" class="headerlink" title="new绑定"></a>new绑定</h3><p>在<code>JavaScript</code>中，使用<code>new</code>操作符后，<code>JavaScript</code>引擎会做如下操作：</p>
<ol>
<li>创建一个原型指向构造函数<code>prototype</code>属性的新对象(继承构造函数的原型)。</li>
<li>执行构造函数，并将<code>this</code>指向第一步中创建的新对象。</li>
<li>如果第二步执行中返回了一个对象，那么将这个对象返回作为结果，否则返回第一步中的新对象。</li>
</ol>
<p>其中第 2 步就是<code>new</code>绑定。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.a = <span class="number">10</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> foo(); <span class="comment">// &#123;a: 10&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.a); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
<p>如果构造函数返回一个对象，那么此时将丢失原来绑定<code>this</code>的新对象。也就是说无法通过实例的属性来访问到原构造函数内部的<code>this</code>（如下例中的<code>obj.a</code>返回的是<code>undefined</code>，而不是预期中的 10），除非显式将<code>this</code>作为属性返回（如下例中的属性 c）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="built_in">this</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> foo();</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123; b: 2 &#125;，而不是 &#123; a: 10 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.a); <span class="comment">// undefined，而不是 10</span></span><br><span class="line"><span class="built_in">console</span>.log(obj.c); <span class="comment">// &#123; a: 10 &#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="this绑定的优先级"><a href="#this绑定的优先级" class="headerlink" title="this绑定的优先级"></a>this绑定的优先级</h3><p><code>new </code>绑定 &gt; 显式绑定 &gt; 隐式绑定 &gt; 默认绑定</p>
<h2 id="判断思路"><a href="#判断思路" class="headerlink" title="判断思路"></a>判断思路</h2><p>按以下步骤进行判定：</p>
<ol>
<li><p>函数是否在<code>new</code>中调用（new绑定）？如果是的话<code>this</code>指向的新创建的对象。</p>
</li>
<li><p>函数是否使用<code>call</code>、<code>apply</code>、<code>bind</code>处理（显式绑定）？如果是的话，<code>this</code>指向指定的对象。</p>
</li>
<li><p>函数是否在上下文对象中调用（隐式绑定）？如果是的话，<code>this</code>指向上下文对象（调用者）。</p>
</li>
<li><p>如果以上条件均不符合（默认绑定）。<code>this</code>指向全局对象（在严格模式下指向<code>undefined</code>）。</p>
</li>
</ol>
<h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>关于箭头函数的this，阮一峰老师有如下定义：</p>
<blockquote>
<p>“箭头函数”的this，总是指向定义时所在的对象，而不是运行时所在的对象。</p>
</blockquote>
<p>其中的“对象”，并不是真的对象，确切的说应该是执行上下文。</p>
<p>即箭头函数的<code>this</code>指向它所定义的时候的上下文，而不是运行时候所在的上下文（普通函数中的this指向运行时的上下文）。</p>
<p>箭头函数本身并没有<code>this</code>绑定，所以在箭头函数中使用this的时候，js会从箭头函数开始，沿着它<strong>定义时</strong>所在的作用域向上寻找，直到找到第一个<code>this</code>绑定为止，该<code>this</code>的指向即为箭头函数的this指向。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;id:&#x27;</span>, <span class="built_in">this</span>.id);</span><br><span class="line">  &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 箭头函数向上查找到foo的this并继承，此时foo的this指向对象&#123;id:42&#125;。</span></span><br><span class="line">foo.call(&#123; <span class="attr">id</span>: <span class="number">42</span> &#125;); <span class="comment">//id: 42</span></span><br></pre></td></tr></table></figure>


<h3 id="箭头函数应用"><a href="#箭头函数应用" class="headerlink" title="箭头函数应用"></a>箭头函数应用</h3><p>箭头函数的一个常用应用，就是用于回调函数中，比如定时器或者事件处理器中的回调函数。</p>
<p>以定时器为例，<code>setTimeout</code>中的普通回调函数中的<code>this</code>默认指向全局对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;window&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> x = &#123;</span><br><span class="line">  name: <span class="string">&#x27;x&#x27;</span>,</span><br><span class="line">  getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;getName&#x27;</span>;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">x.getName(); <span class="comment">// window</span></span><br></pre></td></tr></table></figure>
<p>如果想在回调函数中获取 getName 方法中的<code>this</code>，我们一般会使用下面两种方式</p>
<p>1、将<code>this</code>进行缓存。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;window&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> x = &#123;</span><br><span class="line">  name: <span class="string">&#x27;x&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="title">getName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;getName&#x27;</span>;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="built_in">this</span>;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(self.name);</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">x.getName(); <span class="comment">// getName</span></span><br></pre></td></tr></table></figure>
<p>2、使用<code>bind</code>方法显式绑定<code>this</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;window&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> x = &#123;</span><br><span class="line">  name: <span class="string">&#x27;x&#x27;</span>,</span><br><span class="line">  <span class="function"><span class="title">getName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;getName&#x27;</span>;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">      &#125;.bind(<span class="built_in">this</span>),</span><br><span class="line">      <span class="number">0</span>,</span><br><span class="line">    );</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">x.getName(); <span class="comment">// getName</span></span><br></pre></td></tr></table></figure>

<p>也可以直接使用箭头函数，写法会更简洁明了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;window&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> x = &#123;</span><br><span class="line">  name: <span class="string">&#x27;x&#x27;</span>,</span><br><span class="line">  getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&#x27;getName&#x27;</span>;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 这里直接继承 getName 方法中的 this。</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">x.getName(); <span class="comment">// getName</span></span><br></pre></td></tr></table></figure></div></article></div></main><footer><div class="paginator"><a href="/2018/04/11/against-pyramid-sales/" class="prev">PREV</a><a href="/2017/07/21/RIP-for-chester/" class="next">NEXT</a></div><div class="copyright"><p>© 2017 - 2021 <a href="https://kingluo.me/blog">Kingluo</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div></body></html>